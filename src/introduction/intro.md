# C++ 语言学习笔记

主要由以下部分组成

- *[《现代C++ 语言核心特性解析》](https://www.epubit.com/bookDetails?id=UB77e5a81975b11)谢丙堃，2021* 读书笔记

  <img src="/introduction/book_cover.png" alt="book_cover" style="zoom:33%;" />



## 读书笔记计划内容

同原书，如下

- 第 1 章介绍C++11～C++20 新增的基础类型，包括新的long long 整型和多个新字符类型。
- 第 2 章介绍内联和嵌套命名空间，通过本章读者将学到如何在外部无感知的情况下切换命名空间。
- 第 3 章探讨了新特性中的重点auto 占位符，探究它的推导规则，在lambda 表达式中的应用，这将会是读者在现今C++中用到最多的关键字。
- 第 4 章探讨了decltype 说明符，同样阐述了其推导规则，并将decltype(auto)和auto 做了详细比较，有助于读者厘清两者的区别。
- 第 5 章介绍了函数返回类型后置特性，读者可以通过这种函数声明方式让编译器自动推导返回类型。
- 第 6 章深入探讨了右值引用，该特性是所有新特性中最难理解的特性之一。本章一步一步引导读者理解右值引用的含义和用途，并介绍其在移动语义中发挥的重要作用。另外还深入介绍了值类别，包括泛左值、纯右值和将亡值。
- 第 7 章介绍了lambda 表达式特性，C++11～C++20 逐步递进地讨论了lambda 表达式功能的增强，包括基础语法、广义捕获、泛型lambda 表达式以及如何在lambda表达式中使用模板语法。
- 第 8 章介绍了新的类成员的初始化方法，并且阐述了该方法与初始化列表的区别和优势。
- 第 9 章探究了列表初始化，该特性为初始化容器类型的对象提供了方便。本章详细描述了其工作原理并且演示了如何让自定义容器支持列表初始化。
- 第 10 章介绍了指定默认和删除函数的方法，读者通过本章可以学到如何通过指定默认函数强制编译器生成函数，以及删除特定函数让编译器无法自动生成。
- 第 11 章介绍非受限联合类型，该特性可以解决联合类型在C++中缺乏实用性的问题，通过非受限联合类型可以在联合类型中声明非平凡类型成员。
- 第 12 章和第13 章介绍了委托构造函数和继承构造函数，它们都是为了解决C++类中构造函数代码冗余的问题。
- 第 14 章探究了强枚举类型，强枚举类型解决了普通枚举类型中几个一直被诟病的问题，包括类型检查不严格、底层类型定义不清晰等。
- 第 15 章详细探讨了扩展的聚合类型，阐明聚合类型的新定义，指出该新定义下过去代码中可能出现的问题。
- 第 16 章介绍了override 和final 说明符，说明了重写、重载和隐藏的区别，读者可以通过这两个说明符将虚函数重写的语法检查工作交给编译器。
- 第 17 章深入探讨了基于范围的for 循环，该特性能简化枚举容器中元素的代码，除了描述该特性的使用方法，本章还说明了for 循环的实现原理，并且实现了一个支持基于范围的for 循环容器例子。
- 第 18 章介绍了支持初始化语句的if 和switch，使用该特性可以将变量的初始化以及条件判断统一到相同的作用域。
- 第 19 章介绍了static_assert 关键字，读者可以通过本章了解如何通过static_assert让代码在编译阶段就找到错误。
- 第 20 章深入探讨了结构化绑定的使用方式、规则和原理，通过本章，读者将学会如何让C++像Python 一样返回多个值，如何让一个第三方类型支持结构化绑定语法。
- 第 21 章介绍了noexcept 关键字，描述了noexcept 相对于throw()的优势，并且探讨了noexcept 在作为运算符时如何为移动构造函数提供异常控制的支持。
- 第 22 章讨论了类型别名和别名模板，读者通过本章将学会通过using 关键字定义类型别名，并且掌握别名模板为后续模板的相关特性打下基础。
- 第 23 章介绍了指针字面量nullptr，讨论了nullptr 对比0 作为空指针常量的优势。
- 第 24 章探究了三向比较特性，阐述了三向比较运算符的语法，返回类型特征以及自动生成其他比较运算符的规则。
- 第 25 章介绍了线程局部存储，读者可以从本章了解到编译器和操作系统支持线程局部存储的方法，以及线程局部存储解决了哪些问题。
- 第 26 章介绍了扩展的inline 说明符特性，该特性解决了类的非常量静态成员变量声明必须和定义分开的问题。
- 第 27 章深入探究了常量表达式。本章有一定难度，不仅介绍了使用constexpr定义常量表达式函数、构造函数，并且分不同时期的标准探讨了使常量表达式成立的规则的变化，另外还讨论了constexpr 在if 控制结构、lambda 表达式和虚函数中的应用。
- 第 28 章讨论了表达式求值顺序的问题，新特性解决了C++17 之前C++标准没有对表达式求值顺序做严格规定的问题。
- 第 29 章讨论了新标准对字面量的优化，其中集中描述了新标准对二进制整数、十六进制浮点、原生字符串字面量的支持，另外还详细介绍了如何实现自定义字面量。
- 第 30 章深入探讨了alignas 和alignof 关键字。本章从CPU 的角度出发讨论了数据对齐对于程序运行效率的重要性，进而说明如何使用新标准提供的方式完成数据对齐，最后用实例证明了数据对齐对性能的影响。
- 第 31 章介绍了属性说明符和标准属性，通过本章读者将学会使用属性的方法，了解指定属性的规则，并且能充分理解C++11 到C++20 中的9 个标准属性。
- 第 32 章介绍了新增预处理器和宏。本章展示了使用__has_include 预处理器判断是否包含头文件的方法，并且介绍了一系列的特性测试宏，使用它们可以判断编译器对某个特性的支持程度。
- 第 33 章深入探讨了协程的使用方法和原理，从如何简单地借助标准库使用协程入手，分别诠释了co_await、co_yield 和co_return 运算符原理，并且展示了如何自定义一个支持协程的类型。
- 第 34 章是一些其他基础特性的优化，虽然这些特性比较简短不成体系但是却也相当重要，比如返回值优化，允许数组转换为未知范围的数组等。
- 第 35 章深入讨论了可变参数模板。本章中除了介绍可变参数模板的基本语法，还深入讨论了形参包展开的各种场景，展示了使用可变参数模板进行模板元编程的方法，最后探讨了C++17 中折叠表达式的语法和规则。
- 第 36 章介绍了新标准对typename 的优化，新标准明确指明了可以省略typename的场景，并且让模板参数支持使用typename。
- 第 37 章集中介绍了新标准对模板参数的改进，包括允许局部和匿名类型作为模板实参、将函数模板添加到ADL 查找规则中等。
- 第 38 章讨论了新标准模板推导的优化，在C++17 标准之前实例化类模板必须显式指定模板实参，但是现在不需要了。本章介绍了使用构造函数推导类模板实参的方法以及它在各种场景下的应用。
- 第 39 章介绍了用户定义推导指引，读者通过本章将学到如何通过自定义推导指引来控制编译器推导模板实例路径。
- 第 40 章讨论了SFINAE 规则，通过SFINAE 规则开发人员能够控制编译器选择模板实例化的方法，SFINAE 规则也是模板元编程必不可少的组成部分。
- 第 41 章深入探讨了概念和约束，通过这部分内容读者可以体会到对编译器前所未有的掌控力，概念可以通过各方面约束编译器对模板的实例化。本章详细讨论了concept 和requires 的语法和使用规则，并且展示了其在可变参数模板和auto 中的约束作用。
- 第 42 章介绍了模板特性的其他优化，包括新增的变量模板以及使用friend 声明模板形参的优化等。
